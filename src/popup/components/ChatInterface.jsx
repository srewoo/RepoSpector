import React, { useState, useRef, useEffect } from 'react';
import { Send, Bot, User, Sparkles, AlertCircle, Database, GitBranch, Clock, Network, FileText, Download } from 'lucide-react';
import { Button } from './ui/Button';
import { Modal } from './ui/Modal';
import { CodePreview } from './CodePreview';
import { TokenUsageIndicator } from './TokenUsageIndicator';
import { TypingIndicator } from './TypingIndicator';
import { MarkdownRenderer } from './ui/MarkdownRenderer';
import { MermaidDiagram } from './ui/MermaidDiagram';
import { cn } from '@/lib/utils';
import { useExtension } from '@/hooks/useExtension';
import { conversationHistory } from '@/services/conversationHistory';

/**
 * Format timestamp to relative time (e.g., "just now", "2m ago", "1h ago")
 */
function formatRelativeTime(timestamp) {
    if (!timestamp) return '';

    const now = Date.now();
    const diff = now - timestamp;

    // Less than a minute
    if (diff < 60000) return 'just now';

    // Less than an hour
    if (diff < 3600000) {
        const mins = Math.floor(diff / 60000);
        return `${mins}m ago`;
    }

    // Less than a day
    if (diff < 86400000) {
        const hours = Math.floor(diff / 3600000);
        return `${hours}h ago`;
    }

    // More than a day - show date
    const date = new Date(timestamp);
    return date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
}

export function ChatInterface({ autoGenerateType = null, onBack = null, instanceId = 'popup' }) {
    const [currentRepo, setCurrentRepo] = useState(null);
    const [isRepoIndexed, setIsRepoIndexed] = useState(false);
    const [isMainRepoPage, setIsMainRepoPage] = useState(false);
    const [isPRPage, setIsPRPage] = useState(false);
    // Format message content with custom styling for headers
    const formatMessageContent = (content) => {
        if (!content) return null;

        const lines = content.split('\n');
        return lines.map((line, index) => {
            // Check if line is a header (contains ** markers)
            const lineStr = line || '';
            if (lineStr.includes('**') && lineStr.includes(':')) {
                const headerText = lineStr.replace(/\*\*/g, '').trim();
                return (
                    <div key={index} className="text-base font-bold text-primary mt-2 mb-1">
                        {headerText}
                    </div>
                );
            }
            // Regular line
            return <div key={index}>{line || '\u00A0'}</div>;
        });
    };

    const suggestions = [
        { label: 'Generate unit tests', icon: 'ðŸ§ª' },
        { label: 'Create integration tests', icon: 'ðŸ”—' },
        { label: 'Explain this code', icon: 'ðŸ“–' },
        { label: 'Find issues in this code', icon: 'ðŸ”' },
        { label: 'Suggest improvements', icon: 'ðŸ’¡' },
    ];

    const [messages, setMessages] = useState([
        {
            id: 1,
            role: 'assistant',
            content: "Hi! I'm RepoSpector Copilot. Ask me anything about your code, or click a suggestion below to get started.",
            type: 'welcome'
        }
    ]);
    const [input, setInput] = useState('');
    const messagesEndRef = useRef(null);
    const { sendMessage, initRAG, indexRepo, isLoading, error } = useExtension();
    const [isIndexing, setIsIndexing] = useState(false);
    const [embeddingProvider, setEmbeddingProvider] = useState('openai'); // 'openai' or 'transformers' (transformers not supported in service worker)
    const [modelLoading, setModelLoading] = useState(false);
    const [streamingMessageId, setStreamingMessageId] = useState(null);
    const [autoGenerated, setAutoGenerated] = useState(false);
    const [streamingPhase, setStreamingPhase] = useState(''); // Track current phase of streaming
    const [currentRequestId, setCurrentRequestId] = useState(null); // Track current request ID for correlation
    const [useDeepContext, setUseDeepContext] = useState(false); // Toggle for RAG context

    // Listen for model loading progress and streaming chunks
    // Use ref to access current state without re-registering listener
    const streamingMessageIdRef = useRef(streamingMessageId);
    const currentRequestIdRef = useRef(currentRequestId);

    // Update refs when state changes
    useEffect(() => {
        streamingMessageIdRef.current = streamingMessageId;
    }, [streamingMessageId]);

    useEffect(() => {
        currentRequestIdRef.current = currentRequestId;
    }, [currentRequestId]);

    // Single listener registration without dependencies
    useEffect(() => {
        const handleMessage = (message, sender) => {
            // CRITICAL FIX: Only process runtime messages (not tab messages)
            // This prevents duplicate responses from tab messages
            if (sender && sender.tab) {
                // This message came from a tab, ignore it in popup
                console.debug(`[${instanceId}] Ignoring tab message from tab ${sender.tab.id}`);
                return;
            }

            // Only process messages intended for this instance (popup vs floating panel)
            if (message.targetInstance && message.targetInstance !== instanceId) {
                console.debug(`[${instanceId}] Ignoring message for ${message.targetInstance}`);
                return;
            }

            if (message.type === 'RAG_MODEL_PROGRESS') {
                setModelLoading(true);
                // You could show detailed progress here if needed
            }

            // Handle streaming chunks (for both test generation and chat)
            if (message.action === 'TEST_CHUNK' && message.data) {
                const { chunk, fullContent = '', progress, isLastChunk } = message.data;
                const messageRequestId = message.requestId;

                // Only process chunks for current request
                if (messageRequestId && currentRequestIdRef.current && messageRequestId !== currentRequestIdRef.current) {
                    console.debug(`[${instanceId}] Ignoring chunk for different request: ${messageRequestId} !== ${currentRequestIdRef.current}`);
                    return;
                }

                // Check if this is the last chunk - finalize the message
                if (isLastChunk) {
                    console.log('âœ… Received last chunk, finalizing message');
                    setStreamingPhase('');
                    setCurrentRequestId(null);

                    // Mark message as complete
                    setMessages(prev => {
                        const existingIndex = prev.findIndex(m => m.id === streamingMessageIdRef.current);
                        if (existingIndex >= 0) {
                            const updated = [...prev];
                            updated[existingIndex] = {
                                ...updated[existingIndex],
                                isStreaming: false
                            };
                            setStreamingMessageId(null);
                            return updated;
                        }
                        return prev;
                    });

                    return; // Exit early, no need to process further
                }

                // Update streaming phase based on progress
                const contentLength = (fullContent || '').length;
                if (!streamingMessageIdRef.current) {
                    setStreamingPhase('ðŸ¤– AI analyzing code structure...');
                } else if (contentLength < 100) {
                    setStreamingPhase('ðŸ§  AI understanding context...');
                } else if (contentLength < 500) {
                    setStreamingPhase('âœ¨ AI generating response...');
                } else {
                    setStreamingPhase('ðŸ“ AI writing...');
                }

                setMessages(prev => {
                    // Find or create streaming message
                    const existingIndex = prev.findIndex(m => m.id === streamingMessageIdRef.current);

                    if (existingIndex >= 0) {
                        // Update existing streaming message
                        const updated = [...prev];
                        const currentMsg = updated[existingIndex];

                        // If message type is 'code', update code property
                        // If message type is 'text', update content property
                        if (currentMsg.type === 'code') {
                            updated[existingIndex] = {
                                ...currentMsg,
                                code: fullContent,
                                isStreaming: true,
                                progress
                            };
                        } else {
                            updated[existingIndex] = {
                                ...currentMsg,
                                content: fullContent,
                                isStreaming: true,
                                progress
                            };
                        }
                        return updated;
                    } else {
                        // Create new streaming message
                        // Detect if content looks like code (has backticks, function keywords, etc.)
                        const content = fullContent || '';
                        const looksLikeCode = content.includes('```') ||
                            content.includes('function ') ||
                            content.includes('describe(') ||
                            content.includes('it(') ||
                            content.includes('test(') ||
                            content.includes('expect(');

                        const newId = Date.now();
                        setStreamingMessageId(newId);

                        if (looksLikeCode) {
                            return [...prev, {
                                id: newId,
                                role: 'assistant',
                                content: 'Generating tests...',
                                code: fullContent,
                                type: 'code',
                                isStreaming: true,
                                progress
                            }];
                        } else {
                            return [...prev, {
                                id: newId,
                                role: 'assistant',
                                content: fullContent,
                                type: 'text',
                                isStreaming: true,
                                progress
                            }];
                        }
                    }
                });
            }

            // Handle heartbeat messages (keep connection alive)
            if (message.action === 'HEARTBEAT') {
                console.log('ðŸ’“ Received heartbeat from background');
            }
        };

        chrome.runtime.onMessage.addListener(handleMessage);

        // Also listen for postMessage (for iframe popup where content script relays TEST_CHUNK via postMessage)
        const handlePostMessage = (event) => {
            const message = event.data;
            if (message && message.action === 'TEST_CHUNK' && message.data) {
                // Process the same way as chrome.runtime.onMessage
                handleMessage(message, {});
            }
        };
        window.addEventListener('message', handlePostMessage);

        return () => {
            chrome.runtime.onMessage.removeListener(handleMessage);
            window.removeEventListener('message', handlePostMessage);
        };
    }, []); // Empty dependency array - register listener only once

    // Initialize conversation history and detect current repo
    useEffect(() => {
        const initHistory = async () => {
            await conversationHistory.initialize();

            // Set code context from current tab if available
            try {
                const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
                if (tab && tab.url) {
                    const url = new URL(tab.url);
                    // Detect platform from hostname
                    const host = url.hostname;
                    const isGitPlatform = /github\.com|gitlab\.com|gitlab\.|bitbucket\.org|dev\.azure\.com|visualstudio\.com|sourceforge\.net|codeberg\.org|gitea\.|git\.sr\.ht|pagure\.io/i.test(host);

                    if (isGitPlatform) {
                        const pathParts = url.pathname.split('/').filter(Boolean);
                        if (pathParts.length >= 2) {
                            // Detect platform type
                            let platform = 'github';
                            if (host.includes('gitlab')) platform = 'gitlab';
                            else if (host.includes('bitbucket')) platform = 'bitbucket';
                            else if (host.includes('azure') || host.includes('visualstudio')) platform = 'azure';
                            else if (host.includes('codeberg') || host.includes('gitea')) platform = 'gitea';

                            // For GitLab with nested groups, repoId is everything before /-/
                            let repoId;
                            if (platform === 'gitlab') {
                                const dashIdx = pathParts.indexOf('-');
                                repoId = dashIdx > 0 ? pathParts.slice(0, dashIdx).join('/') : pathParts.slice(0, Math.min(pathParts.length, 3)).join('/');
                            } else {
                                repoId = `${pathParts[0]}/${pathParts[1]}`;
                            }

                            setCurrentRepo({ repoId, platform });

                            // Detect page type from URL
                            const fullPath = url.pathname;

                            // PR/MR page detection (works across all platforms)
                            const isPR = /\/pull\/\d+/.test(fullPath) ||
                                /\/merge_requests\/\d+/.test(fullPath) ||
                                /\/pull-requests\/\d+/.test(fullPath);
                            setIsPRPage(isPR);

                            // Main repo page detection
                            let isMainPage = false;
                            if (platform === 'gitlab') {
                                // GitLab sub-pages use /-/ prefix (e.g. /-/merge_requests, /-/tree, /-/blob)
                                const dashIdx = pathParts.indexOf('-');
                                if (dashIdx === -1) {
                                    isMainPage = true;
                                } else {
                                    const afterDash = pathParts.slice(dashIdx + 1);
                                    isMainPage = afterDash.length === 0 ||
                                        (afterDash[0] === 'tree' && afterDash.length <= 2);
                                }
                            } else if (platform === 'bitbucket') {
                                const subPath = pathParts.slice(2);
                                isMainPage = subPath.length === 0 ||
                                    (subPath[0] === 'src' && subPath.length <= 2);
                            } else {
                                const subPath = pathParts.slice(2);
                                isMainPage = subPath.length === 0 ||
                                    (subPath[0] === 'tree' && subPath.length <= 2);
                            }
                            setIsMainRepoPage(isMainPage);

                            await conversationHistory.setCodeContext({
                                filePath: pathParts.slice(2).join('/'),
                                language: 'auto',
                                repository: repoId
                            });

                            // Check if this repo is indexed
                            try {
                                const response = await chrome.runtime.sendMessage({
                                    type: 'CHECK_INDEX_STATUS',
                                    data: { url: tab.url }
                                });
                                if (response.success) {
                                    setIsRepoIndexed(response.isIndexed);
                                    if (response.isIndexed) {
                                        setUseDeepContext(true); // Auto-enable if repo is indexed
                                    }
                                }
                            } catch (err) {
                                console.error('Failed to check index status:', err);
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('Failed to set code context:', error);
            }
        };

        initHistory();
    }, []);

    // Track messages in conversation history
    useEffect(() => {
        // Save each new message to conversation history (skip initial welcome message)
        if (messages.length > 1) {
            const lastMessage = messages[messages.length - 1];
            if (lastMessage && !lastMessage.isStreaming) {
                conversationHistory.addMessage(lastMessage);
            }
        }
    }, [messages]);

    // Reset autoGenerated flag when autoGenerateType changes
    useEffect(() => {
        if (autoGenerateType) {
            setAutoGenerated(false);
        }
    }, [autoGenerateType]);

    // Auto-generate tests when autoGenerateType is provided
    useEffect(() => {
        if (autoGenerateType && !autoGenerated) {
            setAutoGenerated(true);

            // Trigger test generation automatically
            const generateAuto = async () => {
                const testTypePrompt = autoGenerateType === 'unit'
                    ? 'Generate comprehensive unit tests for this file'
                    : 'Generate comprehensive integration tests for this file';

                // Clear previous messages when starting new generation
                setMessages([{
                    id: 1,
                    role: 'assistant',
                    content: "Hi! I'm RepoSpector Copilot. Ask me anything about your code, or click a suggestion below to get started.",
                    type: 'text'
                }]);

                // Add user message to show what was requested
                const userMessage = {
                    id: Date.now(),
                    role: 'user',
                    content: testTypePrompt,
                    type: 'text'
                };
                setMessages(prev => [...prev, userMessage]);

                // Show initial streaming phase
                setStreamingPhase('ðŸ” Extracting code for AI analysis...');

                try {
                    const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });

                    const response = await sendMessage('GENERATE_TESTS', {
                        tabId: tab?.id,
                        options: {
                            testType: autoGenerateType,
                            contextLevel: 'smart',
                            userPrompt: testTypePrompt
                        },
                        useDeepContext: useDeepContext  // Pass Deep Context toggle state
                    });

                    // Set current request ID for chunk correlation
                    if (response.requestId) {
                        setCurrentRequestId(response.requestId);
                    }

                    if (response.success) {
                        // Always clear streaming phase on successful response
                        setStreamingPhase('');

                        // Only create final message if streaming didn't already handle it
                        const testTypeName = autoGenerateType === 'unit' ? 'unit' : 'integration';

                        if (!streamingMessageId && response.testCases && response.testCases.trim()) {
                            // No streaming message exists, create new one
                            const aiMessage = {
                                id: Date.now() + 1,
                                role: 'assistant',
                                content: `I've generated ${testTypeName} tests using ${response.metadata?.framework || 'default'} for your ${response.metadata?.language || 'code'}:`,
                                type: 'code',
                                code: response.testCases,
                                metadata: response.metadata,
                                testType: testTypeName
                            };
                            setMessages(prev => [...prev, aiMessage]);
                        }
                        // If streamingMessageId exists, the streaming chunks already handled the message
                        if (streamingMessageId) {
                            setStreamingMessageId(null);
                        }
                    } else {
                        // Clear streaming phase on error too
                        setStreamingPhase('');
                        throw new Error(response.error || 'Failed to generate tests');
                    }
                } catch (err) {
                    // Clear streaming phase on error
                    setStreamingPhase('');
                    setStreamingMessageId(null);

                    // Safely extract error message
                    const errMsg = err?.message || err?.toString?.() || String(err) || 'Unknown error';

                    const errorMessage = {
                        id: Date.now() + 1,
                        role: 'assistant',
                        content: `Error: ${errMsg}. Please try again.`,
                        type: 'error'
                    };
                    setMessages(prev => [...prev, errorMessage]);
                }
            };

            generateAuto();
        }
    }, [autoGenerateType, autoGenerated, sendMessage]);

    const scrollToBottom = () => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    };

    useEffect(() => {
        scrollToBottom();
    }, [messages]);

    const [showApiKeyModal, setShowApiKeyModal] = useState(false);
    const [apiKeyInput, setApiKeyInput] = useState('');

    const handleIndexRepoClick = () => {
        if (embeddingProvider === 'openai') {
            setShowApiKeyModal(true);
        } else {
            handleIndexRepo();
        }
    };

    const handleIndexRepo = async (apiKey = null) => {
        setIsIndexing(true);
        setModelLoading(embeddingProvider === 'transformers');

        const providerName = embeddingProvider === 'transformers' ? 'Free (Transformers.js)' : 'OpenAI';
        setMessages(prev => [...prev, {
            id: Date.now(),
            role: 'assistant',
            content: `Starting repository indexing with ${providerName}... ${embeddingProvider === 'transformers' ? 'Loading model (~25MB)...' : 'This may take a moment.'}`,
            type: 'text'
        }]);

        try {
            await initRAG({ provider: embeddingProvider, apiKey });
            setModelLoading(false);

            // Simulate getting files (in real app, we'd fetch from GitHub API)
            const mockFiles = [
                { path: 'src/utils/math.js', content: 'export const add = (a, b) => a + b;' },
                { path: 'src/components/Button.jsx', content: 'export const Button = () => <button>Click</button>;' }
            ];

            await indexRepo('owner/repo', mockFiles);

            setMessages(prev => [...prev, {
                id: Date.now(),
                role: 'assistant',
                content: `Repository indexed successfully with ${providerName}! I can now use Deep Context for your queries.`,
                type: 'text'
            }]);
        } catch (err) {
            setModelLoading(false);
            const errMsg = err?.message || err?.toString?.() || String(err) || 'Unknown error';
            setMessages(prev => [...prev, {
                id: Date.now(),
                role: 'assistant',
                content: `Indexing failed: ${errMsg}`,
                type: 'error'
            }]);
        } finally {
            setIsIndexing(false);
        }
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        if (!input.trim()) return;

        // Reset streaming state for new request
        setStreamingMessageId(null);
        setCurrentRequestId(null);

        const userMessage = { id: Date.now(), role: 'user', content: input, type: 'text' };
        setMessages(prev => [...prev, userMessage]);
        // Save user message to history
        conversationHistory.addMessage(userMessage).catch(console.error);

        const userPrompt = input.toLowerCase();
        setInput('');

        // Show initial streaming phase
        setStreamingPhase('ðŸ” Preparing AI request...');
        console.log('ðŸ“¤ New request submitted:', input);

        try {
            // Detect if this is a test generation request (look for action verbs + test keywords)
            const lowerPrompt = userPrompt.toLowerCase();
            const isTestGeneration = (
                (lowerPrompt.includes('generate') || lowerPrompt.includes('create') || lowerPrompt.includes('write') || lowerPrompt.includes('add') || lowerPrompt.includes('make')) &&
                (lowerPrompt.includes('test') || lowerPrompt.includes('spec'))
            ) || lowerPrompt === 'test' || lowerPrompt === 'tests';

            // Detect mindmap request
            const isMindmapRequest = lowerPrompt.includes('mindmap') && lowerPrompt.includes('repo');

            // Detect repo info request
            const isRepoInfoRequest = lowerPrompt.includes('repo') &&
                (lowerPrompt.includes('repoinfo') || lowerPrompt.includes('repo info'));

            // Detect sequence diagram request
            const isSequenceDiagramRequest = lowerPrompt.includes('sequence') && lowerPrompt.includes('diagram');

            const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });

            // Route to appropriate handler
            if (isMindmapRequest && isRepoIndexed && currentRepo) {
                setStreamingPhase('ðŸ—ºï¸ Generating repo mindmap...');

                const response = await sendMessage('GENERATE_REPO_MINDMAP', {
                    repoId: currentRepo.repoId,
                    url: tab?.url
                });

                setStreamingPhase('');

                if (response.success && response.data?.mermaidCode) {
                    const aiMessage = {
                        id: Date.now() + 1,
                        role: 'assistant',
                        content: `Here's the mindmap for **${currentRepo.repoId}**:`,
                        type: 'mindmap',
                        mermaidCode: response.data.mermaidCode,
                        fallbackCode: response.data.fallbackCode || null
                    };
                    setMessages(prev => [...prev, aiMessage]);
                    conversationHistory.addMessage(aiMessage).catch(console.error);
                } else {
                    throw new Error(response.error || 'Failed to generate mindmap');
                }
            } else if (isMindmapRequest && !isRepoIndexed) {
                setStreamingPhase('');
                const aiMessage = {
                    id: Date.now() + 1,
                    role: 'assistant',
                    content: 'Please index the repository first to generate a mindmap. Use the indexing feature in settings.',
                    type: 'text'
                };
                setMessages(prev => [...prev, aiMessage]);
            } else if (isRepoInfoRequest && isRepoIndexed && currentRepo) {
                setStreamingPhase('Generating RepoInfo.md...');

                const response = await sendMessage('GENERATE_REPO_INFO', {
                    repoId: currentRepo.repoId,
                    url: tab?.url
                });

                setStreamingPhase('');

                if (response.success && response.data?.repoInfoMarkdown) {
                    const aiMessage = {
                        id: Date.now() + 1,
                        role: 'assistant',
                        content: `Here's the complete RepoInfo for **${currentRepo.repoId}**:`,
                        type: 'repoinfo',
                        repoInfoMarkdown: response.data.repoInfoMarkdown,
                        repoId: response.data.repoId
                    };
                    setMessages(prev => [...prev, aiMessage]);
                    conversationHistory.addMessage(aiMessage).catch(console.error);
                } else {
                    throw new Error(response.error || 'Failed to generate RepoInfo');
                }
            } else if (isRepoInfoRequest && !isRepoIndexed) {
                setStreamingPhase('');
                const aiMessage = {
                    id: Date.now() + 1,
                    role: 'assistant',
                    content: 'Please index the repository first to generate RepoInfo.md. Use the indexing feature in settings.',
                    type: 'text'
                };
                setMessages(prev => [...prev, aiMessage]);
            } else if (isSequenceDiagramRequest) {
                // Sequence diagram generation (for PR/diff pages)
                const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
                const prUrl = tab?.url;
                if (!prUrl) throw new Error('Could not detect current page URL');

                setStreamingPhase('Generating sequence diagram...');

                const response = await sendMessage('GENERATE_MERMAID_DIAGRAM', {
                    prUrl
                });

                setStreamingPhase('');

                if (response.success && response.data?.mermaidCode) {
                    const aiMessage = {
                        id: Date.now() + 1,
                        role: 'assistant',
                        content: 'Here\'s the sequence diagram for this PR:',
                        type: 'mindmap',
                        mermaidCode: response.data.mermaidCode
                    };
                    setMessages(prev => [...prev, aiMessage]);
                    conversationHistory.addMessage(aiMessage).catch(console.error);
                } else {
                    throw new Error(response.error || 'Failed to generate sequence diagram');
                }
            } else if (isTestGeneration) {
                // Update phase for test generation
                setStreamingPhase('ðŸ¤– Sending code to AI for test generation...');
                // Test generation flow
                let testType = 'unit'; // Default
                let contextLevel = 'smart';

                if (userPrompt.includes('integration')) {
                    testType = 'integration';
                } else if (userPrompt.includes('e2e') || userPrompt.includes('end-to-end') || userPrompt.includes('end to end')) {
                    testType = 'e2e';
                } else if (userPrompt.includes('api')) {
                    testType = 'api';
                } else if (userPrompt.includes('performance')) {
                    testType = 'performance';
                } else if (userPrompt.includes('security')) {
                    testType = 'security';
                }

                // Parse context level from prompt
                if (userPrompt.includes('comprehensive') || userPrompt.includes('detailed') || userPrompt.includes('full context')) {
                    contextLevel = 'full';
                } else if (userPrompt.includes('minimal') || userPrompt.includes('simple')) {
                    contextLevel = 'minimal';
                }

                const response = await sendMessage('GENERATE_TESTS', {
                    tabId: tab?.id,
                    options: {
                        testType,
                        contextLevel,
                        userPrompt: input
                    },
                    useDeepContext: useDeepContext  // Pass Deep Context toggle state
                });

                // Set current request ID for chunk correlation
                if (response.requestId) {
                    setCurrentRequestId(response.requestId);
                }

                if (response.success) {
                    // Always clear streaming phase on successful response
                    setStreamingPhase('');

                    // Only create final message if streaming didn't already handle it
                    // If streamingMessageId exists, streaming already created the message
                    if (!streamingMessageId && response.testCases && response.testCases.trim()) {
                        // No streaming message exists, create new one
                        const testTypeName = testType === 'unit' ? 'unit' :
                            testType === 'integration' ? 'integration' :
                                testType === 'e2e' ? 'end-to-end' :
                                    testType === 'api' ? 'API' :
                                        testType;

                        const aiMessage = {
                            id: Date.now() + 1,
                            role: 'assistant',
                            content: `I've generated ${testTypeName} tests using ${response.metadata?.framework || 'unit'} for your ${response.metadata?.language || 'code'}:`,
                            type: 'code',
                            code: response.testCases,
                            metadata: response.metadata,
                            testType: testTypeName
                        };
                        setMessages(prev => [...prev, aiMessage]);
                        // Save AI response to history
                        conversationHistory.addMessage(aiMessage).catch(console.error);
                    }
                    // If streamingMessageId exists, the streaming chunks already handled the message
                    // Just clear the streaming state
                    if (streamingMessageId) {
                        setStreamingMessageId(null);
                    }
                } else {
                    // Clear streaming phase on error too
                    setStreamingPhase('');
                    throw new Error(response.error || 'Failed to generate tests');
                }
            } else {
                // General code chat flow (Ask Copilot)
                setStreamingPhase('ðŸ’¬ Asking AI about your code...');

                // Get formatted conversation history
                const history = conversationHistory.getFormattedHistory(true);
                console.log('ðŸ“š Sending conversation history:', history.length, 'messages');

                const response = await sendMessage('CHAT_WITH_CODE', {
                    tabId: tab?.id,
                    question: input,
                    conversationHistory: history,  // ADD conversation history
                    useDeepContext: useDeepContext  // Pass RAG toggle state
                });

                // Set current request ID for chunk correlation
                if (response.requestId) {
                    setCurrentRequestId(response.requestId);
                }

                if (response.success) {
                    // Always clear streaming phase on successful response
                    setStreamingPhase('');

                    // Show truncation warning if context was cut
                    const truncation = response.metadata?.truncation;
                    if (truncation && (truncation.codeTruncated || truncation.ragTruncated)) {
                        const parts = [];
                        if (truncation.codeTruncated) parts.push('code file');
                        if (truncation.ragTruncated) parts.push('repository context');
                        const warningMessage = {
                            id: Date.now(),
                            role: 'system',
                            content: `Note: ${parts.join(' and ')} was truncated to fit token limits. The response may be based on partial context.`,
                            type: 'warning'
                        };
                        setMessages(prev => [...prev, warningMessage]);
                    }

                    // Only create final message if streaming didn't already handle it
                    // If streamingMessageId exists, streaming already created the message
                    if (!streamingMessageId && response.response && response.response.trim()) {
                        // No streaming message exists, create new one
                        const aiMessage = {
                            id: Date.now() + 1,
                            role: 'assistant',
                            content: response.response,
                            type: 'text',
                            metadata: response.metadata
                        };
                        setMessages(prev => [...prev, aiMessage]);
                        // Save AI response to history
                        conversationHistory.addMessage(aiMessage).catch(console.error);
                    }
                    // If streamingMessageId exists, the streaming chunks already handled the message
                    // Just clear the streaming state
                    if (streamingMessageId) {
                        setStreamingMessageId(null);
                    }
                } else {
                    // Clear streaming phase on error too
                    setStreamingPhase('');
                    throw new Error(response.error || 'Failed to get response');
                }
            }
        } catch (err) {
            // Clear streaming phase on error
            setStreamingPhase('');
            setStreamingMessageId(null);
            setCurrentRequestId(null);

            // Safely extract error message
            const errMsg = err?.message || err?.toString?.() || String(err) || 'Unknown error';

            // Provide helpful error messages based on error type
            let errorContent = `Error: ${errMsg}`;
            let suggestions = [];

            if (errMsg.includes('timeout')) {
                errorContent = 'â±ï¸ Request timed out';
                suggestions.push('The operation took too long. Try with a smaller code file or simpler request.');
            } else if (errMsg.includes('API key')) {
                errorContent = 'ðŸ”‘ API Key Error';
                suggestions.push('Please check your API key in settings.');
                suggestions.push('Make sure the key is valid and has sufficient credits.');
            } else if (errMsg.includes('No code found') || errMsg.includes('extract')) {
                errorContent = 'ðŸ“„ Could not extract code from this page';
                suggestions.push('Navigate to a specific code file, or index the repository to ask questions from any page.');
                suggestions.push('Try refreshing the page and reopening the extension.');
            } else if (errMsg.includes('rate limit') || errMsg.includes('429')) {
                errorContent = 'ðŸš¦ Rate limit exceeded';
                suggestions.push('Please wait a moment before trying again.');
                suggestions.push('Consider using a different API key or upgrading your plan.');
            } else if (errMsg.includes('buffer limit') || errMsg.includes('too large')) {
                errorContent = 'ðŸ’¾ Response too large';
                suggestions.push('The code file is too large to process.');
                suggestions.push('Try selecting a smaller section of code.');
            }

            const fullErrorMessage = suggestions.length > 0
                ? `${errorContent}\n\n**Suggestions:**\n${suggestions.map(s => `â€¢ ${s}`).join('\n')}`
                : errorContent + '\n\nPlease try again or contact support if the issue persists.';

            const errorMessage = {
                id: Date.now() + 1,
                role: 'assistant',
                content: fullErrorMessage,
                type: 'error'
            };
            setMessages(prev => [...prev, errorMessage]);
        }
    };

    // Calculate token usage estimate for display
    const estimatedTokens = messages.reduce((total, msg) => {
        // Simple estimation: ~4 chars per token
        return total + Math.ceil((msg.content || '').length / 4);
    }, 0);

    // Get token limit (default to GPT-4o-mini limit if unknown)
    const tokenLimit = 128000; // Will be dynamic based on selected model in future

    return (
        <div className="flex flex-col h-full w-full">
            <div className="flex-1 overflow-y-auto space-y-4 p-4 pb-20 min-h-0">
                {/* Token Usage Indicator */}
                <TokenUsageIndicator
                    messageCount={messages.length}
                    estimatedTokens={estimatedTokens}
                    tokenLimit={tokenLimit}
                    className="mb-4"
                />

                {messages.map((msg) => (
                    <div
                        key={msg.id}
                        className={cn(
                            "flex gap-3",
                            (msg.type === 'code' || msg.type === 'mindmap' || msg.type === 'repoinfo') ? "max-w-full" : "max-w-[90%]",
                            msg.role === 'user' ? "ml-auto flex-row-reverse" : ""
                        )}
                    >
                        <div className={cn(
                            "w-8 h-8 rounded-full flex items-center justify-center shrink-0",
                            msg.role === 'assistant' ? "bg-primary/20 text-primary" : "bg-surfaceHighlight text-text",
                            msg.type === 'error' && "bg-error/20 text-error",
                            msg.type === 'info' && "bg-blue-500/20 text-blue-400",
                            msg.type === 'warning' && "bg-amber-500/20 text-amber-400"
                        )}>
                            {msg.role === 'assistant' && <Bot className="w-5 h-5" />}
                            {msg.role === 'user' && <User className="w-5 h-5" />}
                            {msg.type === 'error' && <AlertCircle className="w-5 h-5" />}
                            {msg.type === 'info' && <Sparkles className="w-5 h-5" />}
                            {msg.type === 'warning' && <AlertCircle className="w-5 h-5" />}
                        </div>

                        <div className={cn("space-y-2", (msg.type === 'code' || msg.type === 'mindmap' || msg.type === 'repoinfo') ? "flex-1 min-w-0" : "w-full")}>
                            {msg.content && (
                                <div className={cn(
                                    "p-3 rounded-2xl text-sm",
                                    msg.role === 'assistant'
                                        ? "bg-surfaceHighlight/50 rounded-tl-none"
                                        : "bg-primary text-white rounded-tr-none whitespace-pre-line",
                                    msg.type === 'error' && "bg-error/10 text-error border border-error/20",
                                    msg.type === 'info' && "bg-blue-500/10 text-blue-300 border border-blue-500/20",
                                    msg.type === 'warning' && "bg-amber-500/10 text-amber-300 border border-amber-500/20"
                                )}>
                                    {msg.role === 'assistant' ? (
                                        <MarkdownRenderer
                                            content={msg.content}
                                            showCopy={msg.type !== 'code' && msg.type !== 'welcome' && msg.type !== 'repoinfo'}
                                        />
                                    ) : (
                                        msg.content
                                    )}
                                </div>
                            )}

                            {/* Clickable suggestion chips on welcome message */}
                            {msg.type === 'welcome' && (
                                <div className="flex flex-wrap gap-2 mt-2">
                                    {suggestions.map((s) => (
                                        <button
                                            key={s.label}
                                            onClick={() => setInput(s.label.toLowerCase())}
                                            className="px-3 py-1.5 text-xs bg-surface hover:bg-surfaceHighlight border border-border rounded-full text-textMuted hover:text-text transition-colors cursor-pointer"
                                        >
                                            {s.icon} {s.label}
                                        </button>
                                    ))}
                                    {/* Main repo page: mindmap + RepoInfo */}
                                    {isMainRepoPage && (
                                        <>
                                            <button
                                                onClick={() => setInput('generate repo mindmap')}
                                                className="px-3 py-1.5 text-xs bg-primary/10 hover:bg-primary/20 border border-primary/30 rounded-full text-primary hover:text-primary transition-colors cursor-pointer flex items-center gap-1"
                                            >
                                                <Network className="w-3 h-3" />
                                                Generate repo mindmap
                                            </button>
                                            <button
                                                onClick={() => setInput('generate repo info')}
                                                className="px-3 py-1.5 text-xs bg-primary/10 hover:bg-primary/20 border border-primary/30 rounded-full text-primary hover:text-primary transition-colors cursor-pointer flex items-center gap-1"
                                            >
                                                <FileText className="w-3 h-3" />
                                                Generate RepoInfo.md
                                            </button>
                                        </>
                                    )}
                                    {/* PR/diff page: sequence diagram + RepoInfo */}
                                    {isPRPage && (
                                        <>
                                            <button
                                                onClick={() => setInput('generate sequence diagram')}
                                                className="px-3 py-1.5 text-xs bg-primary/10 hover:bg-primary/20 border border-primary/30 rounded-full text-primary hover:text-primary transition-colors cursor-pointer flex items-center gap-1"
                                            >
                                                <GitBranch className="w-3 h-3" />
                                                Generate sequence diagram
                                            </button>
                                            <button
                                                onClick={() => setInput('generate repo info')}
                                                className="px-3 py-1.5 text-xs bg-primary/10 hover:bg-primary/20 border border-primary/30 rounded-full text-primary hover:text-primary transition-colors cursor-pointer flex items-center gap-1"
                                            >
                                                <FileText className="w-3 h-3" />
                                                Generate RepoInfo.md
                                            </button>
                                        </>
                                    )}
                                </div>
                            )}

                            {/* Mermaid mindmap rendering */}
                            {msg.type === 'mindmap' && msg.mermaidCode && (
                                <div className="animate-fade-in mt-2">
                                    <MermaidDiagram code={msg.mermaidCode} fallbackCode={msg.fallbackCode} className="rounded-lg" />
                                </div>
                            )}

                            {/* RepoInfo.md rendering */}
                            {msg.type === 'repoinfo' && msg.repoInfoMarkdown && (
                                <div className="animate-fade-in mt-2 space-y-2">
                                    <div className="max-h-[400px] overflow-y-auto bg-background border border-border rounded-lg p-4">
                                        <MarkdownRenderer content={msg.repoInfoMarkdown} showCopy={true} />
                                    </div>
                                    <div className="flex items-center gap-3">
                                        <button
                                            onClick={() => {
                                                try {
                                                    const blob = new Blob([msg.repoInfoMarkdown], { type: 'text/markdown' });
                                                    const url = URL.createObjectURL(blob);
                                                    const a = document.createElement('a');
                                                    a.href = url;
                                                    a.download = `RepoInfo-${(msg.repoId || 'repo').replace(/\//g, '-')}.md`;
                                                    a.click();
                                                    URL.revokeObjectURL(url);
                                                } catch (e) {
                                                    console.error('Download failed:', e);
                                                }
                                            }}
                                            className="text-xs text-textMuted hover:text-text transition-colors flex items-center gap-1"
                                        >
                                            <Download className="w-3 h-3" />
                                            Download RepoInfo.md
                                        </button>
                                    </div>
                                </div>
                            )}

                            {msg.type === 'code' && (
                                <div className="animate-fade-in space-y-3">
                                    <CodePreview
                                        code={msg.code}
                                        language={msg.testType ? `${msg.testType} tests` : 'javascript'}
                                    />

                                    {/* Quick action buttons for test generation */}
                                    {!msg.isStreaming && (
                                        <div className="flex gap-2 flex-wrap">
                                            <Button
                                                size="sm"
                                                variant="outline"
                                                onClick={async () => {
                                                    const prompt = 'generate more test cases for edge cases and error handling';
                                                    const userMessage = { id: Date.now(), role: 'user', content: prompt, type: 'text' };
                                                    setMessages(prev => [...prev, userMessage]);
                                                    setStreamingPhase('ðŸ¤– Sending code to AI for test generation...');

                                                    try {
                                                        const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
                                                        const response = await sendMessage('GENERATE_TESTS', {
                                                            tabId: tab?.id,
                                                            options: {
                                                                testType: 'unit',
                                                                contextLevel: 'smart',
                                                                userPrompt: prompt
                                                            },
                                                            useDeepContext: useDeepContext  // Pass Deep Context toggle state
                                                        });

                                                        if (response.requestId) {
                                                            setCurrentRequestId(response.requestId);
                                                        }
                                                    } catch (err) {
                                                        setStreamingPhase('');
                                                        setMessages(prev => [...prev, {
                                                            id: Date.now(),
                                                            role: 'assistant',
                                                            content: `Error: ${err.message}`,
                                                            type: 'error'
                                                        }]);
                                                    }
                                                }}
                                                className="text-xs"
                                                disabled={isLoading || streamingPhase}
                                            >
                                                <User className="w-3 h-3 mr-1" />
                                                Generate more test cases
                                            </Button>
                                            <Button
                                                size="sm"
                                                variant="outline"
                                                onClick={async () => {
                                                    const prompt = 'add integration tests for this code';
                                                    const userMessage = { id: Date.now(), role: 'user', content: prompt, type: 'text' };
                                                    setMessages(prev => [...prev, userMessage]);
                                                    setStreamingPhase('ðŸ¤– Sending code to AI for test generation...');

                                                    try {
                                                        const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
                                                        const response = await sendMessage('GENERATE_TESTS', {
                                                            tabId: tab?.id,
                                                            options: {
                                                                testType: 'integration',
                                                                contextLevel: 'smart',
                                                                userPrompt: prompt
                                                            },
                                                            useDeepContext: useDeepContext  // Pass Deep Context toggle state
                                                        });

                                                        if (response.requestId) {
                                                            setCurrentRequestId(response.requestId);
                                                        }
                                                    } catch (err) {
                                                        setStreamingPhase('');
                                                        setMessages(prev => [...prev, {
                                                            id: Date.now(),
                                                            role: 'assistant',
                                                            content: `Error: ${err.message}`,
                                                            type: 'error'
                                                        }]);
                                                    }
                                                }}
                                                className="text-xs"
                                                disabled={isLoading || streamingPhase}
                                            >
                                                <User className="w-3 h-3 mr-1" />
                                                Add integration tests
                                            </Button>
                                        </div>
                                    )}
                                </div>
                            )}

                            {/* Message metadata: timestamp and AI badge */}
                            <div className="flex items-center gap-2 mt-1">
                                {/* Timestamp for all messages except first welcome */}
                                {msg.id !== 1 && (
                                    <span className="text-[10px] text-textMuted/50 flex items-center gap-0.5">
                                        <Clock className="w-2.5 h-2.5" />
                                        {formatRelativeTime(msg.id)}
                                    </span>
                                )}
                                {/* AI badge for assistant messages (except first welcome message) */}
                                {msg.role === 'assistant' && msg.id !== 1 && !msg.isStreaming && (
                                    <span className="text-[10px] text-textMuted/50 flex items-center gap-0.5">
                                        <Sparkles className="w-2.5 h-2.5" />
                                        AI
                                    </span>
                                )}
                            </div>
                        </div>
                    </div>
                ))}

                {/* Welcome/Empty State - Removed RAG indexing buttons for cleaner interface */}



                {/* Welcome/Empty State - Removed RAG indexing buttons for cleaner interface */}

                {
                    (isLoading || streamingPhase) && (
                        <div className="flex gap-3">
                            <div className="w-8 h-8 rounded-full bg-primary/20 text-primary flex items-center justify-center">
                                <Sparkles className="w-4 h-4 animate-pulse" />
                            </div>
                            <div className="bg-surfaceHighlight/50 p-3 rounded-2xl rounded-tl-none">
                                {streamingPhase ? (
                                    <div className="flex items-center gap-2">
                                        <div className="flex gap-1">
                                            <div className="w-2 h-2 bg-primary/70 rounded-full animate-bounce" style={{ animationDelay: '0ms' }} />
                                            <div className="w-2 h-2 bg-primary/70 rounded-full animate-bounce" style={{ animationDelay: '150ms' }} />
                                            <div className="w-2 h-2 bg-primary/70 rounded-full animate-bounce" style={{ animationDelay: '300ms' }} />
                                        </div>
                                        <span className="text-sm text-text/80">{streamingPhase}</span>
                                    </div>
                                ) : (
                                    <div className="flex items-center gap-1">
                                        <div className="w-2 h-2 bg-textMuted/50 rounded-full animate-bounce" style={{ animationDelay: '0ms' }} />
                                        <div className="w-2 h-2 bg-textMuted/50 rounded-full animate-bounce" style={{ animationDelay: '150ms' }} />
                                        <div className="w-2 h-2 bg-textMuted/50 rounded-full animate-bounce" style={{ animationDelay: '300ms' }} />
                                    </div>
                                )}
                            </div>
                        </div>
                    )
                }
            </div >

            <Modal
                isOpen={showApiKeyModal}
                onClose={() => setShowApiKeyModal(false)}
                title="Enter OpenAI API Key"
                footer={
                    <>
                        <Button variant="ghost" onClick={() => setShowApiKeyModal(false)}>Cancel</Button>
                        <Button onClick={() => {
                            setShowApiKeyModal(false);
                            handleIndexRepo(apiKeyInput);
                        }}>Start Indexing</Button>
                    </>
                }
            >
                <div className="space-y-4">
                    <p className="text-sm text-textMuted">
                        To generate embeddings for your code, we need your OpenAI API key.
                        Your key is only used locally and never stored on our servers.
                    </p>
                    <input
                        type="password"
                        value={apiKeyInput}
                        onChange={(e) => setApiKeyInput(e.target.value)}
                        placeholder="sk-..."
                        className="w-full bg-surfaceHighlight border border-white/10 rounded-lg p-2 text-text focus:outline-none focus:border-primary transition-colors"
                    />
                </div>
            </Modal>

            {/* Input Area */}
            <div className="p-4 bg-surface border-t border-border shrink-0">
                {/* Repo Context Toggle - Only show if repo is detected */}
                {currentRepo && (
                    <div className="flex items-center justify-between mb-3 px-1">
                        <div className="flex items-center gap-2">
                            <GitBranch className="w-3.5 h-3.5 text-textMuted" />
                            <span className="text-xs text-textMuted truncate max-w-[120px]">
                                {currentRepo.repoId}
                            </span>
                            {isRepoIndexed && (
                                <span className="text-[10px] bg-success/20 text-success px-1.5 py-0.5 rounded-full flex items-center gap-1">
                                    <Database className="w-2.5 h-2.5" />
                                    Indexed
                                </span>
                            )}
                        </div>
                        {isRepoIndexed && (
                            <label className="flex items-center gap-2 cursor-pointer group">
                                <div className="relative">
                                    <input
                                        type="checkbox"
                                        checked={useDeepContext}
                                        onChange={(e) => setUseDeepContext(e.target.checked)}
                                        className="sr-only peer"
                                    />
                                    <div className="w-8 h-4 bg-surfaceHighlight rounded-full peer-checked:bg-primary transition-colors" />
                                    <div className="absolute left-0.5 top-0.5 w-3 h-3 bg-white rounded-full transition-transform peer-checked:translate-x-4" />
                                </div>
                                <span className={cn(
                                    "text-xs transition-colors",
                                    useDeepContext ? "text-primary font-medium" : "text-textMuted group-hover:text-text"
                                )}>
                                    Use Repo Context
                                </span>
                            </label>
                        )}
                    </div>
                )}

                <form onSubmit={handleSubmit} className="relative">
                    <input
                        type="text"
                        value={input}
                        onChange={(e) => setInput(e.target.value)}
                        placeholder={useDeepContext && isRepoIndexed
                            ? `Ask about ${currentRepo?.repoId || 'your code'}...`
                            : "Ask about your code or generate tests..."
                        }
                        className="w-full bg-surfaceHighlight border border-border rounded-xl pl-4 pr-12 py-3 text-sm text-text focus:outline-none focus:border-primary/50 focus:ring-1 focus:ring-primary/50 transition-all placeholder:text-textMuted/50"
                        disabled={isLoading || isIndexing}
                    />
                    <Button
                        type="submit"
                        size="icon"
                        disabled={!input.trim() || isLoading || isIndexing}
                        className="absolute right-1.5 top-1.5 h-9 w-9 rounded-lg bg-primary/10 text-primary hover:bg-primary hover:text-white transition-all disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                        <Send className="w-4 h-4" />
                    </Button>
                </form>
            </div>
        </div >
    );
}
